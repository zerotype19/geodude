/**
 * Citations Engine
 * Track where domain appears in AI answer sources
 */

import { fetchCitationsBrave } from './citations-brave';

interface Env {
  DB: D1Database;
  BRAVE_SEARCH?: string;
  BRAVE_SEARCH_ENDPOINT?: string;
  CITATIONS_MAX_PER_QUERY?: string;
  CITATIONS_DAILY_BUDGET?: string;
}

export type CitationType = 'AEO' | 'GEO' | 'Organic';

export interface Citation {
  engine: string;
  query: string;
  url: string;
  title: string | null;
  cited_at: number;
  type: CitationType;
  pagePathname?: string | null; // Added for Phase D
}

/**
 * Extract pathname from URL for filtering citations by page
 */
function extractPathname(url: string): string | null {
  try {
    const urlObj = new URL(url);
    return urlObj.pathname.replace(/\/+$/, '') || '/';
  } catch {
    return null;
  }
}

/**
 * Classify citation as AEO (Answer Engine Optimization), GEO (Generative Engine Optimization), or Organic
 * 
 * AEO: Pure answer engines (Perplexity, You.com, Poe)
 * GEO: Traditional search with AI features (Google AI Overview, Bing Copilot)
 * Organic: Standard search results
 */
export function classifyCitation(citation: Citation): CitationType {
  const url = citation.url.toLowerCase();
  const title = (citation.title || '').toLowerCase();
  
  // Extract hostname for domain-based classification
  let hostname = '';
  try {
    hostname = new URL(citation.url).hostname.toLowerCase();
  } catch {}
  
  // AEO: Pure answer engines
  const aeoHosts = [
    'perplexity.ai',
    'poe.com',
    'you.com',
    'phind.com',
    'komo.ai',
    'andi.com',
  ];
  
  for (const host of aeoHosts) {
    if (hostname.includes(host)) {
      return 'AEO';
    }
  }
  
  // Brave "AI Answer" blocks (when available in future API versions)
  if (citation.engine === 'brave' && (title.includes('ai answer') || title.includes('ai summary'))) {
    return 'AEO';
  }
  
  // GEO: Traditional search with AI overlays
  // Conservative detection - only when we can confirm AI feature usage
  const geoIndicators = [
    'ai overview',
    'ai-generated',
    'generated by ai',
    'copilot',
    'gemini',
    'bard',
  ];
  
  for (const indicator of geoIndicators) {
    if (title.includes(indicator) || url.includes(indicator)) {
      return 'GEO';
    }
  }
  
  // Check for Google/Bing search results (potential GEO but default to Organic)
  if (hostname.includes('google.com') || hostname.includes('bing.com')) {
    // Could be GEO, but without explicit AI indicators, mark as Organic
    // to avoid over-claiming
    return 'Organic';
  }
  
  // Default: Organic search result
  return 'Organic';
}

export async function fetchCitations(
  env: Env,
  auditId: string,
  domain: string,
  brand?: string,
  budgetCheck?: () => Promise<boolean>
): Promise<Citation[]> {
  // Check if we have any citations stored for this audit
  const existing = await env.DB.prepare(
    `SELECT engine, query, url, title, cited_at
     FROM citations
     WHERE audit_id = ?
     ORDER BY cited_at DESC`
  ).bind(auditId).all<Citation>();

  // If we have citations, classify them and add pathname
  if (existing.results && existing.results.length > 0) {
    return existing.results.map(c => ({
      ...c,
      type: classifyCitation(c),
      pagePathname: extractPathname(c.url)
    }));
  }

  // Check budget before fetching (optional)
  if (budgetCheck) {
    const budgetOk = await budgetCheck();
    if (!budgetOk) {
      console.warn(`Citations budget exceeded for audit ${auditId}, skipping fetch`);
      return [];
    }
  }

  // Otherwise, try to fetch from Brave (best-effort, ignore errors)
  try {
    const braveCitations = await fetchCitationsBrave(env, domain, brand);
    
    // Classify and add pathname to citations
    const classifiedCitations = braveCitations.map(c => ({
      ...c,
      type: classifyCitation(c),
      pagePathname: extractPathname(c.url)
    }));
    
    for (const citation of classifiedCitations) {
      await storeCitation(env, auditId, citation);
    }
    
    // Log result with classification breakdown
    const aeoCount = classifiedCitations.filter(c => c.type === 'AEO').length;
    const geoCount = classifiedCitations.filter(c => c.type === 'GEO').length;
    console.log(`citations {audit:${auditId}, found:${classifiedCitations.length}, AEO:${aeoCount}, GEO:${geoCount}}`);
    
    return classifiedCitations;
  } catch (error) {
    console.warn('Failed to fetch Brave citations:', error);
    return [];
  }
}

export async function storeCitation(
  env: Env,
  auditId: string,
  citation: Omit<Citation, 'cited_at'>
): Promise<void> {
  await env.DB.prepare(
    `INSERT INTO citations (audit_id, engine, query, url, title, cited_at)
     VALUES (?, ?, ?, ?, ?, ?)`
  ).bind(
    auditId,
    citation.engine,
    citation.query,
    citation.url,
    citation.title,
    Date.now()
  ).run();
}

